# 데이터 분석, R고 싶니

> 지은이 백종일 / 발행처 비제이퍼블릭 / 2018년
>
> 읽고 정리한 내용입니다.

<br>

## Chapter 2. BASIC

### 객체와 벡터

#### 객체

* 어떠한 데이터가 들어가 있는 공간(바구니)   (= 변수)
* 모든 값을 넣을 수 있는 바구니

<br>

#### 벡터

* 데이터를 나타낼 수 있는 가장 작은 단위
* is() : 괄호 안에 들어 있는 벡터의 속성을 확인하는 함수 ex) "numeric" "vector" 로 반환
* is.vector() : 벡터가 맞는지 확인하는 함수 ex) True / False 로 반환

![img](https://sunghan-kim.github.io/assets/images/lecture/FE_quant/r/part01/ch02/img001.jpg)

![img](https://t1.daumcdn.net/cfile/tistory/9935A1485A5FFB2D14)

<br>

### 백터의 종류 (integer, numeric, character, factor)

* 정수형 (integer)
* 실수형 (numeric)
* 문자형 (character) 
* 문자형 변수: 명목형, 순서형 (factor) >> 순서나 계층(또는 분류) 관계가 존재하는 문자형 벡터

<br>

#### 숫자형(numeric, integer) 벡터

* as.integer() : 숫자 데이터를 넣은 벡터에서는 numeric이 힘이 강하기 때문에 numeric이  아닌 integer 벡터를 생성하기 위해선 as.integer() 함수를 사용해야 한다.

<br>

#### character (문자형 벡터)

<br>

#### factor(명목형 벡터, 순서형 벡터)

기준값 사이에 우열 (순서) 관계가 존재하는가?

=> yes 순서형 벡터

=> no 명목형 벡터

<br>

명목형 벡터의 생성은 factor함수를 사용한다. 

```R
a <- factor("수박", "키위", "체리")

# 레벨값만 추가하고 벡터값은 넣지 않으려면
levels(a) <- c(levels(a), "사과", "바나나")
```

<br>
순서형 벡터를 생성하는 방법은 두 가지가 존재한다.

1. 명목형 벡터를 순서형 벡터로 속성 변경
2. 처음부터 순서형 벡터로 지정

```R
# 명목형 벡터를 순서형 벡터로
b <- as.ordered(a)

# 'ordered' 함수를 사용해 순서형 벡터로
c <- ordered(벡터, levels=카테고리 순서)

# factor 함수를 사용하여 인자로 ordered를 추가하여 순서형 벡터
d <- factor(벡터, ordered=T, levels = 카테고리 순서)
 ## levels 인자는 부가적으로, 목적에 따라 사용 유무를 결정하면 된다.
```

<br>

### 객체의 속성

* 데이터 프레임 (dataframe)
* 리스트(list)
* 매트릭스 (matrix)

<Br>

#### 데이터 프레임

* 가로 세로를 기준으로 행과 열이 존재하고 각 영역에 데이터(백터)가 들어가 있다.
* 두 개 이상의 객체를 한 개의 데이터프레임으로 통합할 때 주의할 점은 객체 내 벡터의 크기(길이)가 모두 동일해야 한다.
* data.frame()
* 가로와 세로, 그리고 데이터가 들어가 있으며 바둑판 모양이다. 가로 축을 '관측치', '행'이라고 부르고, 세로 축을 '열', '변수', '컬럼(column)'이라고 한다.

<br>

#### 매트릭스

* 행과 열로 이루어져 있는 객체의 속성
* 데이터프레임과의 가장 큰 차이는 매트릭스에는 오직 숫자만 입력 가능하다.
* 매트릭스 생성 및 수정시 'matrix' 함수를 사용

```R
matrix(c(1,2,3,4,5,6,7,8), nrow=2, ncol=4)
 ## nrow = 행의 개수 (number of row)
 ## ncol = 열의 개수 (number of column)

# 열 기준으로 생성되는데 행 기준으로 생성하기 위해서는 byrow = True 로 인자를 추가하면 된다.
```

<br>

#### 리스트

* 리스트 자체로도 의미 있지만, 포함할 수 있는 객체의 속성에 제한이 없다. 어떤 속성의 객체든 리스트에 넣을 수 있다.
* list()

<br>

### 데이터셋 불러오기, 저장하기

#### 데이터셋 파일로 저장하기

1. csv => write.csv(데이터셋, '저장 파일명.csv')

2. txt => write.table(데이터셋, '저장 파일명.txt')

3. xlsx => write.xlsx(데이터셋, '저장 파일명.xlsx')  >> 'xlsx' 패키지 필요

   > install.packages("xlsx")
   >
   > library(xlsx)

<br>

#### 다양한 형식의 외부 파일 불러오기

1. csv => read.csv('파일명.csv')
2. txt => read.table('파일명.txt')
3. xlsx => write.xlsx('파일명.xlsx')  >> 'xlsx' 패키지 필요

* header = T 	>> 불러올 데이터셋의 1행을 변수명으로 사용한다는 의미.
* sep = "\t"        >> seperate의 줄임말로 각 데이터의 경계를 무엇으로 두고 불러올 것인지 지정해주는 부분. (csv나 xlsx는 데이터의 입력이 셀(cell) 기준이기 때문에, 셀 자체가 데이터의 구분자가 된다. txt 확장자는 셀 구분이 없어 sep을 통해 데이터를 구분한다.)
* xlsx에서 header 앞에 숫자 1의 의미는 시트의 번호를 의미 한다.
* stringAsFactor 인자는 문자열을 factor로 가져올 것인지 판단을 내리는 인자. True는 factor로 로드, False는 문자열로 가져온다.

<br>

### 데이터셋 구성요소

#### 데이터프레임 구성요소 정의

* 데이터셋 : 테이블 모양의 데이터 그룹
* 관측치 : 1개 행 전체
* 변수 : 열 이름 및 열에 소속된 데이터
* 관측값 : 관측치 내의 데이터들
* 변수값 : 각 열 내에 속한 데이터
* 데이터 : 데이터셋 내에 존재하는 1개 또는 2개 이상의 값 (넓은 의미)

> ​	변수는 열 이름을 의미한다. 일반적인 프로그래밍에서 변수의 개념이 R에서는 '객체'로 정의 되고 변수는 데이터셋에서 열의 기준을 나타낸다.

<br>

### 데이터셋, 객체의 구조 확인하기

#### str 함수를 활용, 숲의 관점으로 데이터셋과 객체의 '구조' 보기

str 함수를 통해 데이터셋 및 객체의 구조와 크기 및 변수 등 간략한 내용을 파악한다. str은 structure의 줄임말이다. 이 과정을 거침으로써 내가 가져온 데이터셋의 구조가 무엇이고, 속성이 무엇인지, 관측치와 변수의 종류가 무엇인지 파악 가능.

```R
str(iris)
```

<br>

#### head와 tail 함수를 활용, 나무의 관점으로 데이터를 세밀하게 보기

```R
head(iris)
head(iris, 10)
tail(iris)
tail(iris,10)
```

<br>

### 데이터셋의 분할과 통합

#### 데이터셋 행(관측치) / 열 분할하기

```r
# 행
iris3 <- iris[1:100, ]
iris4 <- iris[101:150, ]

# 열
iris5 <- iris[, 1:3]
iris6 <- iris[, 4:5]
```

<br>

####  데이터 행(관측치) / 열 통합하기

**행**

* rbind() 사용 >> row bind
* 예를 들어, 두 개의 데이터셋을 행 기준으로 하나의 데이터셋으로 합칠 때 주의할 점은 합치려는 두 데이터셋의 '열(변수)의 개수 및 이름, 그리고 자료형'이 모두 동일해야 한다.

**열**

* cbind() 사용 >> column bind
* 열 기준으로 여러 개의 데이터셋을 하나로 합치는 함수
* merge 함수 사용 (관측치 순서가 다른 열 통합하기)

<br>

### 데이터 선택하기 

#### 특정 위치의 데이터(관측치) 선택하기

객체[객체$변수 + 부등호 + 조건, 추출 원하는 변수]

<br>

